#Unity 3D Homework 1
##简答题

解释游戏对象（GameObjects)和资源（Assets）的区别与联系。
  答：对象是指直接出现在游戏场景中，玩家能看到或者听到的事物，是组成游戏场景的基本部分，是资源整合的具体表现。玩家、敌人、NPC、物理环境的组成物件等都是对象。
      资源是对象的修饰部件，可重复使用。有些资源可作为模板，实例化成游戏中具体的对象，资源可用于修改游戏场景和游戏对象属性。资源文件夹通常有Materials(材质）、Perfabs（预制体）、Scenes（场景）、Scripts（脚本）、Sounds（音频）、Vedio、Textures（贴图）等。

下载几个游戏案例，分别总结资源、对象组织的结构
  答：在显式支持面向对象的语言中，”对象”一般是指类在内存中装载的实例，具有相关的成员变量和成员函数(也称为方法)。对象一般都是直接体现于游戏的场景中，整合了各种游戏的资源。对象一般指游戏中玩家、队友、敌人、周围生物、环境事物、摄像机和音乐等虚拟父类，这些父节点本身没有实体，但它们的子类真正包含了游戏中会出现的对象。而资源文件夹通常有对象、材质、场景、声音、预设、贴图、脚本、动作，在这些文件夹下可以继续进行划分。资源可以被多个对象使用。有些资源作为模板，可实例化成游戏中具体的对象。

编写一个代码，使用debug语句来验证MonoBehaviour基本行为或事件触发的条件

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class BehaviourTest : MonoBehaviour {
    private void Awake()
    {
        Debug.Log("Awake!");
    }
    // Use this for initialization
    void Start () {
        Debug.Log("Start");
	}	
	// Update is called once per frame
	void Update () {
        Debug.Log("Update");
	}
    private void FixedUpdate()
    {
        Debug.Log("FixedUpdate");
    }
    private void LateUpdate()
    {
        Debug.Log("LateUpdate");
    }
    private void OnGUI()
    {
        Debug.Log("OnGUI");
    }
    private void OnDisable()
    {
        Debug.Log("OnDisable");
    }
    private void OnEnable()
    {
        Debug.Log("OnEnable");
    }
}
（1）当一个脚本实例被载入时Awake被调用。 （2）Start仅在Update函数第一次被调用前调用。 （3）当MonoBehaviour启用时，其Update在每一帧被调用。 （4）渲染和处理GUI事件时调用OnGUI。 （5）当MonoBehaviour启用时，其 FixedUpdate?在每一帧被调用。 （6）当Behaviour启用时，其LateUpdate在每一帧被调用。 （7）Reset,重置为默认值。 （8）当对象变为不可用或非激活状态时OnDisable函数被调用。 （9）当MonoBehaviour将被销毁时,OnDestory函数被调用
查找脚本手册，了解GameObject，Transform，Component对象
  答：GameObject：Unity场景中所有实体的基本类。
Transform：一个对象的位置、旋转和比例。场景中的每一个对象都有Transform组件，用来保存和操作对象的位置、旋转度和比例。每一个Transform都可以拥有一个父类，可以通过分层体系来更改位置、旋转和比例。
Component：任何与GameObject联系起来的东西的基本类。你的代码不能直接创建一个Component。但是，你可以通过写脚本代码，然后将代码绑定到GameObject上。

上图中，table的属性有：activelnHierarchy、activeSelf、isStatic、layer、scene、tag、transform；
对于table的transform属性，从图中可以看到，它的localPosition的三个轴向值均为0，Rotation的三个轴向值也为0，而它的Scale属性三个轴向值均为1。
table的组件有Transform、Mesh Filter、Box Collider、Mesh Renderer和Materials。
三者的关系如下图：

整理相关学习资料，编写简单代码验证以下技术的实现：
查找对象：
    通过对象名称：static GameObject Find(string name)
    通过标签获取单个游戏对象：static GameObject FindWithTag (string tag)
    获取多个对象(标签):static GameObject[] FindGameObjectsWithTag(string tag)
    通过类型获取单个对象：static Object FindObjectOfType(Type type)
    获取多个对象(类型):static Object FindObjectsOfType(Type type)
添加子对象：public static GameObect CreatePrimitive(PrimitiveTypetype)
遍历对象树：
List lst = new List;
foreach (Transform child in transform)
{
    lst.Add(child); 
    Debug.Log(child.gameObject.name);
}
清除所有子对象：

foreach(Transform child in transform) 
{
	Destroy(child.gameObject);
}
资源预设（Perfabs）与对象克隆（clone）：预设有什么好处？预设与对象克隆关系？
  答：资源预设能够完整地储存编辑好的对象及其组件和属性，若再需要创建此对象，可直接将预设当做模板，快速将对象创建出来，总之，资源预设使得资源可以重用。当利用预设创建一个新的对象时，新的对象类似于克隆出来的，不同的是，实例化出来的对象与预设之间具有关联性，当改变预设的属性时，可将所有由预设实例出来的对象的属性都改变。而克隆出来的对象和本体之间不会互相影响，各自独立。
制作 table 预制，写一段代码将 table 预制资源实例化成游戏对象
using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class clone : MonoBehaviour {
    Transform table;
	// Use this for initialization
	void Start () {
        table = gameObject.GetComponent<Transform>();
        GameObject anotherTable = (GameObject)Instantiate(table.gameObject);
        anotherTable.transform.position = new Vector3(0, 3, 0);
        anotherTable.transform.parent = this.transform;
	}
	
	// Update is called once per frame
	void Update () {	
	}
}
尝试解释组合模式（Composite Pattern / 一种设计模式）。使用BroadcastMessage() 方法向子对象发送消息
  答：组合模式，又称之为“部分-整体”模式，属于对象结构型模式。其定义为：组合多个对象形成树形结构以表示具有部分-整体关系的层次结构。组合模式让客户端可以统一的对待单个对象和组合对象。组合模式中包含三种角色：Component（抽象构件）、Leaf（叶子构件）、Composite（容器构件）
父对象：
public class Father : MonoBehaviour {
    void test()
    {
        Debug.Log("Hello, my son!");
    }
	// Use this for initialization
	void Start () {
        this.BroadcastMessage("test");
	}
}
子对象：

public class Child : MonoBehaviour {
    void test()
    {
        Debug.Log("Hello, father");
    }
	// Use this for initialization
	void Start () {
		
	}
}
运行结果：
